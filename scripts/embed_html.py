# embed_html.py
# This script runs for each build environment.
# It checks if the current environment is 'wokwi' and, if so,
# reads specified .gz files and generates 'include/embedded_html.h'
# with their binary content as C++ byte arrays.

import os
from SCons.Script import DefaultEnvironment

env = DefaultEnvironment()

# --- Script Configuration ---
SOURCES_CONFIG = [
    {
        "path": "data/index.html.gz",
        "var_name": "index_html_gz"
    },
    {
        "path": "data/lib/chart.umd.min.js.gz",
        "var_name": "chart_umd_min_js_gz"
    }
]
TARGET_HEADER_PATH = os.path.join("include", "embedded_html.h")
TARGET_ENV = "wokwi"
# --------------------------

# Only run this script for the 'wokwi' environment
if env.subst("$PIOENV") != TARGET_ENV:
    print(f"Skipping GZ embedding for '{env.subst('$PIOENV')}' environment.")
    env.Exit(0)

print(f"Running script to embed GZ for '{TARGET_ENV}' environment...")

project_dir = env.subst("$PROJECT_DIR")
header_path = os.path.join(project_dir, TARGET_HEADER_PATH)

# Ensure the target directory exists
os.makedirs(os.path.dirname(header_path), exist_ok=True)

# Prepare the C++ header file content
header_content = f"""/*
 * This file is auto-generated by 'embed_html.py'.
 * Do not edit this file manually.
 */
#pragma once
#include <stdint.h>
"""

any_source_found = False

for config in SOURCES_CONFIG:
    source_path = os.path.join(project_dir, config["path"])
    var_name = config["var_name"]

    # Read the source GZ file in binary mode
    try:
        with open(source_path, "rb") as f:
            binary_content = f.read()
            any_source_found = True
    except FileNotFoundError:
        print(f"WARNING: Source file not found at '{source_path}'. Skipping.")
        continue

    # Format the binary content as a C byte array
    hex_array = ", ".join([f"0x{byte:02x}" for byte in binary_content])

    # Append content to the header
    header_content += f"""

// Gzipped Content of {config['path']}
const uint8_t {var_name}[] PROGMEM = {{
  {hex_array}
}};

const size_t {var_name}_len = sizeof({var_name});
"""

if not any_source_found:
    print("ERROR: No source files found. Header file will not be generated.")
    env.Exit(1)


# Write the header file only if content has changed
should_write = True
try:
    with open(header_path, "r", encoding="utf-8") as f:
        if f.read() == header_content:
            should_write = False
except FileNotFoundError:
    pass

if should_write:
    with open(header_path, "w", encoding="utf-8") as f:
        f.write(header_content)
    print(f"SUCCESS: Generated '{TARGET_HEADER_PATH}' with updated content.")
else:
    print(f"INFO: '{TARGET_HEADER_PATH}' is already up-to-date.")
